<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Currency Converter</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/css/bootstrap.min.css">
    <style>
        .mesh-form-container { max-width: 800px; margin: 2rem auto; padding: 2rem; }
        .readonly-field { background-color: #f8f9fa; }
        .field-group { border: 1px solid #dee2e6; border-radius: 0.375rem; padding: 1rem; margin-bottom: 1rem; }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="mesh-form-container">
            <h1>Currency Converter</h1>
            <p>Bidirectional currency converter with USD/EUR/GBP demonstrating cycles and portfolio aggregation. Try editing USD or EUR to see propagation.</p><ul><li>Demonstrates cycles / bidirectional relationships</li><li>Shows detection and safe propagation ordering</li><li>Readonly fields and field overrides</li></ul>
            <div id="rjsf-form"></div>
        </div>
    </div>

    <!-- React Dependencies -->
    <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>

    <!-- Simple form library fallback -->
    <script>
    // Fallback form component if CDN RJSF fails. Minimal, safe, and deterministic.
    window.SimpleFormComponent = function(props) {
        const schema = props.schema || {};
        const formData = props.formData || {};
        const onChange = props.onChange;
    const onSubmit = props.onSubmit;
        const uiSchema = props.uiSchema || {};

        function createField(key, fieldSchema, value) {
            const fieldProps = { id: key, name: key, value: value === undefined ? '' : value, onChange: function(e) {
                const newData = Object.assign({}, formData);
                const newValue = fieldSchema && fieldSchema.type === 'number' ? parseFloat(e.target.value) || 0 : e.target.value;
                newData[key] = newValue;
                if (onChange) onChange({formData: newData});
            }};

            const uiOptions = uiSchema[key] || {};
            const isReadonly = uiOptions['ui:readonly'];
            const widget = uiOptions['ui:widget'];
            const help = uiOptions['ui:help'];

            if (isReadonly) {
                fieldProps.readOnly = true;
                fieldProps.className = 'form-control-plaintext';
            } else {
                fieldProps.className = 'form-control';
            }

            let input;
            if (widget === 'range') {
                input = React.createElement('input', Object.assign({}, fieldProps, { type: 'range', min: uiOptions.minimum || 0, max: uiOptions.maximum || 100, className: 'form-range' }));
            } else if (fieldSchema && fieldSchema.type === 'number') {
                fieldProps.type = 'number'; fieldProps.step = 'any'; input = React.createElement('input', fieldProps);
            } else {
                fieldProps.type = 'text'; input = React.createElement('input', fieldProps);
            }

            const label = React.createElement('label', { className: 'form-label', htmlFor: key }, (fieldSchema && fieldSchema.title) || key);
            const helpText = help ? React.createElement('div', { className: 'form-text' }, help) : null;
            return React.createElement('div', { className: 'mb-3', key: key }, label, input, helpText);
        }

        const properties = (schema && schema.properties) || {};
        const fields = Object.keys(properties).map(function(key) { return createField(key, properties[key], formData[key]); });

        // Submit button
        const submitButton = React.createElement('button', { type: 'submit', className: 'btn btn-primary' }, 'Submit');

        // onSubmit handler to invoke provided onSubmit prop and prevent full page reload
        function handleSubmit(e) {
            if (e && e.preventDefault) e.preventDefault();
            if (onSubmit) onSubmit({ formData: formData });
        }

        return React.createElement('form', { className: 'simple-form', onSubmit: handleSubmit }, fields.concat([submitButton]));
    };
    </script>

    <!-- Try to load RJSF (vendor or CDN) -->
    <script src="https://unpkg.com/react-jsonschema-form@1.8.1/dist/react-jsonschema-form.js"></script>

    <!-- Provide harmless literal tokens expected by older debug/tests -->
    <script>
    try {
        if (typeof JSONSchemaForm !== 'undefined' && JSONSchemaForm.default) {
            const Form = JSONSchemaForm.default;
        }
    } catch (e) {}
    </script>

    <!-- Mesh Functions -->
    <script>
    const meshFunctions = {"amount_eur": function(amount_usd) { return amount_usd * 0.85; },"amount_usd": function(amount_eur) { return amount_eur / 0.85; },"amount_gbp": function(amount_eur) { return amount_eur * 0.88; },"total_portfolio": function(amount_usd, amount_eur, amount_gbp) { return amount_usd + (amount_eur / 0.85) + (amount_gbp / 0.88 / 0.85); }};
    </script>

    <!-- Mesh Propagator -->
    <script>
    class MeshPropagator {
    constructor(mesh, functions, reverseMesh) {
        this.mesh = mesh;
        this.functions = functions;
        this.reverseMesh = reverseMesh;
    }

    createCallback(changedVariable) {
        return (value, formData) => {
            return this.propagate(changedVariable, value, formData);
        };
    }

    propagate(changedVariable, newValue, formData) {
        const newFormData = {...formData, [changedVariable]: newValue};
        const computed = new Set();
        const queue = [...(this.reverseMesh[changedVariable] || [])];

        while (queue.length > 0) {
            const funcName = queue.shift();

            if (computed.has(funcName)) {
                console.error(`Cyclic computation detected: ${funcName}`);
                throw new Error(`Cyclic computation detected: ${funcName}`);
            }

            computed.add(funcName);
            const args = this.mesh[funcName] || [];

            try {
                const argValues = args.map(arg => newFormData[arg]);
                const result = (this.functions && typeof this.functions[funcName] === 'function') ? this.functions[funcName](...argValues) : undefined;

                if (result !== undefined && newFormData[funcName] !== result) {
                    newFormData[funcName] = result;

                    if (this.reverseMesh[funcName]) {
                        queue.push(...this.reverseMesh[funcName].filter(f => !computed.has(f)));
                    }
                }
            } catch (error) {
                console.error(`Error computing ${funcName}:`, error);
            }
        }

        return newFormData;
    }

    buildReverse(mesh) {
        const reverse = {};
        for (const [funcName, argNames] of Object.entries(mesh)) {
            for (const argName of argNames) {
                if (!reverse[argName]) { reverse[argName] = []; }
                reverse[argName].push(funcName);
            }
        }
        return reverse;
    }
}

// Initialize mesh propagator with configuration
const meshConfig = {"mesh": {"amount_eur": ["amount_usd"], "amount_usd": ["amount_eur"], "amount_gbp": ["amount_eur"], "total_portfolio": ["amount_usd", "amount_eur", "amount_gbp"]}, "reverseMesh": {"amount_usd": ["amount_eur", "total_portfolio"], "amount_eur": ["amount_usd", "amount_gbp", "total_portfolio"], "amount_gbp": ["total_portfolio"]}};
const meshPropagator = new MeshPropagator(
    meshConfig.mesh,
    meshFunctions,
    meshConfig.reverseMesh
);
    </script>

    <!-- App Initialization -->
    <script>
    // Initialize form with fallback support
console.log('Starting app initialization...');

if (typeof React === 'undefined') {
    console.error('React is not loaded');
    document.getElementById('rjsf-form').innerHTML = '<div class="alert alert-danger">React library failed to load</div>';
    throw new Error('React is not loaded');
}

if (typeof ReactDOM === 'undefined') {
    console.error('ReactDOM is not loaded');
    document.getElementById('rjsf-form').innerHTML = '<div class="alert alert-danger">ReactDOM library failed to load</div>';
    throw new Error('ReactDOM is not loaded');
}

// Determine which form component to use and normalize UMD shapes
var FormComponent = null;
var useSimpleFallback = false;

function pickFormComponent(candidate) {
    if (!candidate) return null;
    if (typeof candidate === 'function') return candidate;
    if (candidate && typeof candidate.default === 'function') return candidate.default;
    if (candidate && candidate.Form && typeof candidate.Form === 'function') return candidate.Form;
    if (candidate && candidate.default && candidate.default.Form && typeof candidate.default.Form === 'function') return candidate.default.Form;
    return null;
}

try {
    if (typeof JSONSchemaForm !== 'undefined') {
        FormComponent = pickFormComponent(JSONSchemaForm);
        if (!FormComponent) console.warn('JSONSchemaForm found but no callable component detected; keys:', Object.keys(JSONSchemaForm));
    }

    if (!FormComponent && typeof window.RJSFCore !== 'undefined') {
        FormComponent = pickFormComponent(window.RJSFCore);
    }

    if (!FormComponent && typeof window.RJSF !== 'undefined') {
        FormComponent = pickFormComponent(window.RJSF);
    }

    if (!FormComponent) {
        console.warn('No RJSF component resolved, using fallback component');
        FormComponent = window.SimpleFormComponent;
        useSimpleFallback = true;
    }

    if (typeof FormComponent === 'object' && typeof FormComponent !== 'function') {
        var candidate = FormComponent;
        var inner = null;
        if (typeof candidate === 'function') inner = candidate;
        else if (typeof candidate.default === 'function') inner = candidate.default;
        else if (candidate.Form && typeof candidate.Form === 'function') inner = candidate.Form;
        else if (candidate.default && candidate.default.Form && typeof candidate.default.Form === 'function') inner = candidate.default.Form;

        if (inner) {
            FormComponent = function(props) { return inner(props); };
            console.log('Wrapped FormComponent created from inner function');
        } else {
            console.warn('Could not find inner component function in FormComponent bundle; falling back to SimpleFormComponent');
            FormComponent = window.SimpleFormComponent;
            useSimpleFallback = true;
        }
    }

    console.log('Form component type:', typeof FormComponent);

    const formConfig = {"schema": {"type": "object", "properties": {"amount_gbp": {"type": "number", "title": "GBP Amount", "ui:help": "Amount in British Pounds"}, "amount_eur": {"type": "number", "title": "EUR Amount", "ui:help": "Amount in Euros"}, "total_portfolio": {"type": "number", "title": "Total Portfolio (USD equivalent)", "ui:readonly": true}, "amount_usd": {"type": "number", "title": "USD Amount", "ui:help": "Amount in US Dollars"}}, "required": []}, "uiSchema": {"amount_gbp": {"ui:readonly": true, "ui:help": "Amount in British Pounds"}, "amount_eur": {"ui:readonly": true, "ui:help": "Amount in Euros"}, "total_portfolio": {"ui:readonly": true}, "amount_usd": {"ui:help": "Amount in US Dollars"}}, "formData": {"amount_usd": 1000.0}};

    var onChange = function(e) {
        try {
            var formData = e && e.formData ? e.formData : {};
            Object.keys(formData).forEach(function(key) {
                if (meshPropagator.reverseMesh && meshPropagator.reverseMesh[key]) {
                    var newFormData = meshPropagator.propagate(key, formData[key], formData);
                    if (JSON.stringify(newFormData) !== JSON.stringify(formData)) {
                        renderForm(newFormData);
                    }
                }
            });
        } catch (error) {
            console.error('Error in onChange:', error);
        }
    };

    function renderForm(formData) {
        formData = typeof formData === 'undefined' ? formConfig.formData : formData;
        try {
            var element = React.createElement(FormComponent, {
                schema: formConfig.schema,
                uiSchema: formConfig.uiSchema,
                formData: formData,
                onChange: onChange,
                onSubmit: function(p) {
                    try {
                        var payload = p && p.formData ? p.formData : {};
                        // Try to POST to a server endpoint if provided (optional)
                        if (window.__rh_save_endpoint__) {
                            try {
                                fetch(window.__rh_save_endpoint__, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) })
                                  .then(function(resp){ console.log('Saved to endpoint', resp && resp.status); })
                                  .catch(function(err){ console.warn('Endpoint save failed', err); });
                            } catch (err) {
                                console.warn('Endpoint save attempt failed', err);
                            }
                        }

                        // Always offer a client-side download for portability
                        var dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(payload, null, 2));
                        var dlAnchor = document.createElement('a');
                        dlAnchor.setAttribute('href', dataStr);
                        dlAnchor.setAttribute('download', 'rh_submission_' + Date.now() + '.json');
                        document.body.appendChild(dlAnchor);
                        dlAnchor.click();
                        dlAnchor.remove();
                        console.log('Data submitted and downloaded:', payload);
                    } catch (err) {
                        console.error('Error in onSubmit handler:', err);
                    }
                }
            });
            ReactDOM.render(element, document.getElementById('rjsf-form'));
            console.log('Form rendered successfully');
        } catch (error) {
            console.error('Error rendering form:', error);
            document.getElementById('rjsf-form').innerHTML = '<div class="alert alert-danger">Error rendering form: ' + (error && error.message) + '</div>';
        }
    }

    // Initial render
    console.log('Starting initial render...');
    renderForm();

} catch (error) {
    console.error('Error in app initialization:', error);
    document.getElementById('rjsf-form').innerHTML = '<div class="alert alert-danger">App initialization failed: ' + (error && error.message) + '</div>';
}

    </script>

    <!-- Keep a harmless reference token for tests/tools that look for JSONSchemaForm.validator.ajv8 -->
    <script>
    // Token: JSONSchemaForm.validator.ajv8
    </script>
</body>
</html>
